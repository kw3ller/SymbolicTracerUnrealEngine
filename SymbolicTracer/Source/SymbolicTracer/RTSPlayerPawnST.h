// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "DataStructs.h"
#include "EAbstractionLevel.h"
#include "EInstructionType.h"
#include "GameFramework/Pawn.h"
#include "RTSPlayerPawnST.generated.h"


class ARunAnimationActorST;
class AInstructionSplineActorST;
// delegate for updating the Hud (updated run and instruction indices and also updated codeFile and codeLine indices)
DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FTwoIntIndexesUpdated,
											 int, GeneralNewInd, // codeFileInd
											 int, SpecificNewInd); // codeLineInd

// delegate for updating the Hud (updated run and instruction indices and also updated codeFile and codeLine indices)
DECLARE_DYNAMIC_MULTICAST_DELEGATE_FourParams(FFourIntIndexesUpdated,
											 int, GeneralNewInd, // runInd, codeFileInd
											 int, SpecificNewInd, // instrInd, codeLineInd
											 int, MoreSpecificNewInd, // StepInd
											 int, MoreMoreSpecificNewInd); // ScrollStepId

// delegate for updating the Hud (updated run index for MinimalLayoutHUD)
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FIntIndexUpdated,
											 int, GeneralNewInd); // runInd)


// forward declarations

enum class EInstructionType : uint8;
class UCameraComponent;
class USpringArmComponent;
class ASceneActorBase;
class AInstructionActorST;
class ACodeBlockActorST;

/*
 * the rts player pawn
 */ 
UCLASS()
class SYMBOLICTRACER_API ARTSPlayerPawnST : public APawn
{
	GENERATED_BODY()

	// ---VARIABLES---

public:

	// used for animating run -> start stop animation via this thread 
	// UPROPERTY()
	//AThreadAnimator* AnimationThread = nullptr;

	// is a runAnimation running? -> use this to start/stop run animations
	UPROPERTY()
	bool RunAnimationRunning = false;

	// is a runAnimation running? -> use this to start/stop run animations
	UPROPERTY()
	bool FollowAnimationWithCamera = true;

	// the index of the run that is being animated (if < 0 -> animate whole trace) // TODO: make that happen
	UPROPERTY()
	int CurrentRunAnimationIndex = 0;

	// the current runAnimationActor we want to animate 
	UPROPERTY()
	ARunAnimationActorST* CurrentRunAnimationActor = nullptr;

	// the current instruction actor that is marked (e.g. by animation) 
	UPROPERTY()
	AInstructionActorST* MarkedInstructionActor = nullptr;

	// timer for marking instructionLine via instructionLineMarkActor
	UPROPERTY()
	FTimerHandle TimerHandleInstructionLineMark;
	
	// timer for marking instructionSpline via instructionLineSplineActor
	UPROPERTY()
	FTimerHandle TimerHandleInstructionSplineMark;

	// mark InstructionSplineActor (e.g. when clicking on jump)
	UPROPERTY()
	TObjectPtr<AInstructionSplineActorST> MarkedInstructionSplineActor = nullptr;

	
	// this is the main traceStruct that was generated by the ptrace json data
	UPROPERTY()
	FTraceInstr TraceInstrStructure;

	// this is the main traceStruct that was generated by the blk json data
	UPROPERTY()
	FTraceBlk TraceBlkStructure;

	// indicates the level of abstraction in which the trace data is shown in
	UPROPERTY()
	EAbstractionLevel AbstractionLevel = EAbstractionLevel::Level0;


	// maps the instructionType from json to the enumInstructionType 
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	TMap<FString, EInstructionType> InstructionTypeTable = {
		{"Jump", EInstructionType::Jump},
		{"Arith", EInstructionType::Arith},
		{"Store", EInstructionType::Store},
		{"Load", EInstructionType::Load},
		{"Branch", EInstructionType::Branch},
		{"ECALL", EInstructionType::ECALL},
	};

	// this is the material the instruction spline actor can be marked with -> choose the right one in blueprints
	// TODO: Make that it HAS TO be set
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Instruction Spline Mark Material")
	TObjectPtr<UMaterial> InstrSplineMarkMaterial = nullptr;

	// material for symbolic behaviour create
	// TODO: Make that it HAS TO be set
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Symbolic behaviour Material")
	TObjectPtr<UMaterialInterface> SymBehCreateMaterial = nullptr;

	// material for symbolic behaviour destroy
	// TODO: Make that it HAS TO be set
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Symbolic behaviour Material")
	TObjectPtr<UMaterialInterface> SymBehDestroyMaterial = nullptr;

	// material for symbolic behaviour update
	// TODO: Make that it HAS TO be set
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Symbolic behaviour Material")
	TObjectPtr<UMaterialInterface> SymBehUpdateMaterial = nullptr;

	// material for symbolic behaviour overwrite
	// TODO: Make that it HAS TO be set
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Symbolic behaviour Material")
	TObjectPtr<UMaterialInterface> SymBehOverwriteMaterial = nullptr;

	// material for symbolic behaviour special
	// TODO: Make that it HAS TO be set
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Symbolic behaviour Material")
	TObjectPtr<UMaterialInterface> SymBehSpecialMaterial = nullptr;

	// material for symbolic behaviour none
	// TODO: Make that it HAS TO be set
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Symbolic behaviour Material")
	TObjectPtr<UMaterialInterface> SymBehNoneMaterial = nullptr;

	// maps the symbolic behaviour to the material
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	TMap<FString, UMaterialInterface*> SymBehMaterialTable;

	// this is the actor symbolising instructions in the symbolic run -> choose the right one in blueprints
	// TODO: Make that it HAS TO be set
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Spawning")
	TSubclassOf<AInstructionActorST> InstructionActor;

	// this is the actor symbolising instruction text in the symbolic run (opcode) -> choose the right one in blueprints
	// TODO: Make that it HAS TO be set
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Spawning")
	TSubclassOf<AInstructionTextActorST> InstructionTextActor;

	// this is the actor for animating control flow through runs -> choose the right one in blueprints
	// TODO: Make that it HAS TO be set
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Spawning")
	TSubclassOf<ARunAnimationActorST> RunAnimationActor;

	// this is the actor symbolising the pathTexts in the symbolic run -> choose the right one in blueprints
	// TODO: Make that it HAS TO be set
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Spawning")
	TSubclassOf<APathTextActorST> PathTextActor;

	// this is the actor symbolising instructions in the symbolic run -> choose the right one in blueprints
	// TODO: Make that it HAS TO be set
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Spawning")
	TSubclassOf<AInstructionLineActorST> InstructionLineActor;

	// this is the actor symbolising the control flow between instructions -> choose the right one in blueprints
	// TODO: Make that it HAS TO be set
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Spawning")
	TSubclassOf<AInstructionSplineActorST> InstructionSplineActor;

	// this is the actor symbolising the control flow between paths (parent child run relationship) -> choose the right one in blueprints
	// TODO: Make that it HAS TO be set
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Spawning")
	TSubclassOf<APathSplineActorST> PathSplineActor;

	// this is the actor symbolising instruction marker in the symbolic run -> choose the right one in blueprints
	// TODO: Make that it HAS TO be set
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Spawning")
	TSubclassOf<AInstructionLineMarkActorST> InstructionLineMarkActor;

	// this is the actor symbolising codeBlocks in the symbolic run -> choose the right one in blueprints
	// TODO: Make that it HAS TO be set
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Spawning")
	TSubclassOf<ACodeBlockActorST> CodeBlockActor;

	// this is the actor symbolising codeBlocks Counts in the symbolic run -> choose the right one in blueprints
	// TODO: Make that it HAS TO be set
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Spawning")
	TSubclassOf<ACodeBlkCountActorST> CodeBlkCountActor;

	// this is the actor symbolising functionBlocks in the symbolic run -> choose the right one in blueprints
	// TODO: Make that it HAS TO be set
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Spawning")
	TSubclassOf<AFunctionBlockActorST> FunctionBlockActor;

	// this is the actor symbolising functionTexts in the symbolic run -> choose the right one in blueprints
	// TODO: Make that it HAS TO be set
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Spawning")
	TSubclassOf<AFunctionTextActorST> FunctionTextActor;

	// this is the actor symbolising codeBlockTexts in the symbolic run -> choose the right one in blueprints
	// TODO: Make that it HAS TO be set
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Spawning")
	TSubclassOf<ACodeBlkTextActorST> CodeBlkTextActor;

	// delegate to use when clicked run and or clicked instruction index changes
	UPROPERTY(BlueprintAssignable)
	FFourIntIndexesUpdated OnRunInstrStepIndexChanged;

	// delegate to use when clicked run and or clicked codeBlock index changes
	UPROPERTY(BlueprintAssignable)
	FTwoIntIndexesUpdated OnRunCodeBlockIndexChanged;

	// delegate to use when clicked codeFile or codeLine index changes
	UPROPERTY(BlueprintAssignable)
	FTwoIntIndexesUpdated OnCodeFileLineIndexChanged;

	// delegate to use when clicked runIndex changes (for minimalLayout)
	UPROPERTY(BlueprintAssignable)
	FIntIndexUpdated OnRunIndexChanged;

	

protected:

	// for @TraceInstrStructure and @TraceBlkStructure -> updated when clicking on PathTextActor in Scene
	UPROPERTY()
	int ClickedOnlyRunIndex = -1;

	// for @TraceInstrStructure and @TraceBlkStructure -> updated when clicking on an actor in the scene
	UPROPERTY()
	int ClickedRunIndex = -1;

	// for @TraceInstrStructure -> updated when clicking on an actor in the scene
	UPROPERTY()
	int ClickedInstructionIndex = -1;

	// for @TraceInstrStructure -> updated when clicking on an actor in the scene
	UPROPERTY()
	int ClickedStepIndex = -1;

	// for @TraceInstrStructure -> updated when clicking on an actor in the scene
	UPROPERTY()
	int ClickedStepId = -1;

	// for @TraceBlkStructure -> updated when clicking on an actor in the scene
	UPROPERTY()
	int ClickedCodeBlockIndex = -1;

	// for @TraceBlkStructure -> updated when loadingCodeFiles or clicking on them in the Hud
	UPROPERTY()
	int ClickedCodeFileIndex = -1;

	// for @TraceBlkStructure -> updated when loadingCodeFiles or clicking on them in the Hud
	UPROPERTY()
	int ClickedCodeLineIndex = -1;
	

	// These are all for camera movement
	UPROPERTY(BlueprintReadWrite, EditAnywhere, Category="Settings|Camera")
	float MoveSpeed = 20.0f;

	UPROPERTY(BlueprintReadWrite, EditAnywhere, Category="Settings|Camera")
	float RotateSpeed = 2.0f;

	UPROPERTY(BlueprintReadWrite, EditAnywhere, Category="Settings|Camera")
	float RotatePitchMin = 10.0f;

	UPROPERTY(BlueprintReadWrite, EditAnywhere, Category="Settings|Camera")
	float RotatePitchMax = 80.0f;

	UPROPERTY(BlueprintReadWrite, EditAnywhere, Category="Settings|Camera")
	float ZoomSpeed = 2.0f;

	UPROPERTY(BlueprintReadWrite, EditAnywhere, Category="Settings|Camera")
	float MinZoom = 100.0f;

	UPROPERTY(BlueprintReadWrite, EditAnywhere, Category="Settings|Camera")
	float MaxZoom = 4000.0f;

private:

	UPROPERTY(BlueprintReadWrite, VisibleAnywhere, meta = (AllowPrivateAccess = "true"))
	TObjectPtr<USceneComponent> SceneComponent;

	UPROPERTY(BlueprintReadWrite, VisibleAnywhere, meta = (AllowPrivateAccess = "true"))
	TObjectPtr<USpringArmComponent> SpringArmComponent;

	UPROPERTY(BlueprintReadWrite, VisibleAnywhere, meta = (AllowPrivateAccess = "true"))
	TObjectPtr<UCameraComponent> CameraComponent;

	UPROPERTY()
	FVector TargetLocation;

	UPROPERTY()
	FRotator TargetRotation;

	UPROPERTY()
	float TargetZoom;

	UPROPERTY()
	bool CanRotate;

	

	// ---METHODS---

public:

	// Sets default values for this pawn's properties
	ARTSPlayerPawnST();

	// Called every frame
	virtual void Tick(float DeltaTime) override;

	// Called to bind functionality to input
	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;

	// returns clicked run index
	UFUNCTION(BlueprintPure)
	int GetClickedRunIndex() const;

	// returns clicked instruction index
	UFUNCTION(BlueprintPure)
	int GetClickedInstructionIndex() const;

	// the user selects the directory where the processed trace date is located
	UFUNCTION(BlueprintCallable)
	FString SelectDataDir();	

	// loads the json data into @TraceInstrStructure
	UFUNCTION(BlueprintCallable)
	void LoadTraceInstrData(FString DataDir);

	// loads the json data into @TraceBlkStructure
	UFUNCTION(BlueprintCallable)
	void LoadTraceBlkData(FString DataDir);

	// loads a code file into @TraceBlkStructure
	UFUNCTION(BlueprintCallable)
	void LoadCodeFiles(FString DataDir);

	// loads codeLinesDataEntries List into @TraceBlkStructure (inside each CodeFile)
	UFUNCTION(BlueprintCallable)
	void ComputeCodeFilesLinesDataEntries();

	// computes all the codeLines that are compiled
    void ComputeCompiledCodeLinesAndPc();
	
	// compute codeBlockBeginning and codeBlockEnding for all codeLines and also that these blocks of code are hit
	void ComputeBlocksCodeLines();

	// computes all the codeLines that are hit by individual instructions
	// also compute symbolized and conretized behaviour for this codeLine 
	void ComputeHitCodeLinesSymCon();

	// compute branchCount and branchHit for all codeLines
	void ComputeBranchCodeLines();

	// compute coverage percentage for each codeFile and in general
	void ComputeCodeCovPercentage();
	
	// computes general analysis data and analysis data for each run individually
	void ComputeAnalysisData();

	// broadcasts the current state (e.g. @ClickedRunIndex, @ClickedInstructionIndex)
	// is pretty much only needed, when Hud in another viewMode (so that the other views get updated information (even when not seen)
	void BroadcastCurrentStats() const;

	// when clicking on an instructionActor in the scene
	UFUNCTION(BlueprintCallable)
	void ClickInstructionActor(int RunInd, int InstrInd, int StepInd, int StepId);

	// when clicking on an codeBlockActor in the scene
	UFUNCTION(BlueprintCallable)
	void ClickCodeBlockActor(int RunInd, int CodeBlockInd);

	// when clicking on an pathTextActor in the scene
	UFUNCTION(BlueprintCallable)
	void ClickPathTextActor(int RunInd);

	// when clicking on a codeFile in the Hud
	UFUNCTION(BlueprintCallable)
	void ClickCodeFile(int FileInd);

	// when clicking on a codeFile in the Hud
	UFUNCTION(BlueprintCallable)
	void ChangeAbstractionLevel(EAbstractionLevel Level);

	// shall spawn instructionActors for 3D, InstructionSplines in 3D, InstructionTextActors
	// also spawn instructionActors for 2D, Splines for 2D
	// also calculate max_depth in analysis
	void SpawnInstrObjects();

	// shall spawn pathSplineActors
	void SpawnPathSplineObjects();

	// set if animation shall be followed by camera
	UFUNCTION(BlueprintCallable)
	void SetFollowAnimationWithCamera(bool Follow);

	// jump to end of animation of the given run
	UFUNCTION(BlueprintCallable)
	void JumpAnimationToEnd(int AnimationRunIndex);

	// resets the whole animation of the given run
	UFUNCTION(BlueprintCallable)
	void ResetAnimation(int AnimationRunIndex);

	// resets the symbolic materials of the given run (e.g. for instructionActors) (as if the run starts from AnimationStepId)
	UFUNCTION()
	void ResetSymMaterials(int AnimationRunIndex, int AnimationStepIndex);

	// set start of animation if it is not running currently 
	UFUNCTION(BlueprintCallable)
	void SetAnimationStart(int AnimationRunIndex, int AnimationStepId);
	

	// TODO:
	// when animation is running -> mark instructionActor -> (like outline and scroll to right position etc)
	// also scroll to right codePosition etc.
	// also change Material to the current step symbolic behaviour material
	UFUNCTION(BlueprintCallable)
	void MarkInstructionActor(int RunIndex, int InstructionIndex, int StepIndex, int ScrollStepId);

	
	// shall stop run animation from bellow
	UFUNCTION(BlueprintCallable)
	void StopRunAnimation();
	
	// shall animate the given run
	UFUNCTION(BlueprintCallable)
	void AnimateRun(int AnimationRunIndex);
	
	// spawns runAnimationObjects for each path and one for the whole run
	void SpawnRunAnimationObjects();

	// shall spawn instructionLineActors
	void SpawnInstrLineObjects();

	// shall spawn functionBlockActors and the functionTextActors
	void SpawnFunctionBlkTextObjects();

	// shall spawn pathTextActors
	void SpawnPathTextObjects();

	// shall spawn codeBlockActors
	void SpawnBlkObjects();

	// shall spawn codeBlkTextActors
	void SpawnBlkTextObjects();
	
	// these are ll camera movement functions
	UFUNCTION()
	void Forward(float AxisValue);

	UFUNCTION()
	void Right(float AxisValue);

	// teleports player to a programCounter (RunInd and InstrInd come from the clicked instruction form which we jump)
	UFUNCTION(BlueprintCallable)
	void TeleportToPc(int32 Pc, int RunInd, int InstrInd, int StepInd, bool Branch);
	
	// spawns an Actor for few seconds in the Scene to mark an instructionLine
	UFUNCTION(BlueprintCallable)
	void MarkPcInScene(int32 Pc);

	// deSpawns an Actor that marked an instructionLine
	UFUNCTION(BlueprintCallable)
	void UnMarkPcInScene();

	UFUNCTION(BlueprintCallable)
	void MarkInstrSplineInScene(int RunInd, int InstrInd, int StepInd, bool Branch);

	UFUNCTION(BlueprintCallable)
	void UnMarkInstrSplineInScene();

	UFUNCTION()
	void Zoom(float AxisValue);

	UFUNCTION()
	void RotateRight();

	UFUNCTION()
	void RotateLeft();

	UFUNCTION()
	void EnableRotate();

	UFUNCTION()
	void DisableRotate();

	UFUNCTION()
	void RotateHorizontal(float AxisValue);

	UFUNCTION()
	void RotateVertical(float AxisValue);
	
protected:

	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

	

private:

	UFUNCTION()
	void CameraBounds();
	


};


